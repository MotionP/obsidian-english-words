/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EnglishWordsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var https = __toESM(require("https"));
function httpsRequest(options) {
  return new Promise((resolve, reject) => {
    const parsed = new URL(options.url);
    const req = https.request(
      {
        hostname: parsed.hostname,
        port: parsed.port || 443,
        path: parsed.pathname + parsed.search,
        method: options.method,
        headers: options.headers,
        rejectUnauthorized: false
      },
      (res) => {
        const chunks = [];
        res.on("data", (chunk) => chunks.push(chunk));
        res.on("end", () => {
          resolve({
            status: res.statusCode || 0,
            body: Buffer.concat(chunks).toString("utf-8")
          });
        });
      }
    );
    req.on("error", reject);
    if (options.body) {
      req.write(options.body);
    }
    req.end();
  });
}
var DEFAULT_SETTINGS = {
  gigachatCredentials: "",
  filePath: "English Words.md"
};
var OAUTH_URL = "https://ngw.devices.sberbank.ru:9443/api/v2/oauth";
var CHAT_URL = "https://gigachat.devices.sberbank.ru/api/v1/chat/completions";
var SYSTEM_PROMPT = "You are a linguistic assistant. Your response must be structured as follows:\n- **word**: the English word or a message indicating it's not an English word.\n- **part_of_speech**: the part of speech in Russian (\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0435, \u043F\u0440\u0438\u043B\u0430\u0433\u0430\u0442\u0435\u043B\u044C\u043D\u043E\u0435, \u0433\u043B\u0430\u0433\u043E\u043B, \u043D\u0430\u0440\u0435\u0447\u0438\u0435, etc.).\n- **translation**: the Russian translation or a message indicating it's not an English word.\n- **transcription**: IPA phonetic transcription or a message indicating it's not an English word.\n- **pronunciation**: approximate Russian pronunciation hint or a message indicating it's not an English word.\n- **examples**: 3 common everyday example sentences using the word. Each example must have the sentence in English and its Russian translation. Choose sentences that are frequently used in daily life.\nIf the input is not an English word, respond with 'This is not an English word.' for each field.\n\nReply ONLY with the structured data, no extra text. Use exactly this format:\nword: <word>\npart_of_speech: <part of speech in Russian>\ntranslation: <translation>\ntranscription: <transcription>\npronunciation: <pronunciation>\nexample1_en: <sentence>\nexample1_ru: <translation>\nexample2_en: <sentence>\nexample2_ru: <translation>\nexample3_en: <sentence>\nexample3_ru: <translation>";
function generateUUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
async function getAccessToken(credentials) {
  const response = await httpsRequest({
    url: OAUTH_URL,
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Accept: "application/json",
      Authorization: `Basic ${credentials}`,
      RqUID: generateUUID()
    },
    body: "scope=GIGACHAT_API_PERS"
  });
  const data = JSON.parse(response.body);
  if (!data.access_token) {
    throw new Error(`GigaChat auth failed: ${response.body}`);
  }
  return data.access_token;
}
function parseResponse(text) {
  const lines = text.split("\n");
  const result = {};
  for (const line of lines) {
    const colonIndex = line.indexOf(":");
    if (colonIndex === -1)
      continue;
    const key = line.substring(0, colonIndex).trim().toLowerCase();
    const value = line.substring(colonIndex + 1).trim();
    result[key] = value;
  }
  return {
    word: result["word"] || "",
    partOfSpeech: result["part_of_speech"] || "",
    translation: result["translation"] || "",
    transcription: result["transcription"] || "",
    pronunciation: result["pronunciation"] || "",
    example1_en: result["example1_en"] || "",
    example1_ru: result["example1_ru"] || "",
    example2_en: result["example2_en"] || "",
    example2_ru: result["example2_ru"] || "",
    example3_en: result["example3_en"] || "",
    example3_ru: result["example3_ru"] || ""
  };
}
async function lookupWord(word, credentials) {
  const token = await getAccessToken(credentials);
  const body = JSON.stringify({
    model: "GigaChat-Pro",
    temperature: 0.1,
    messages: [
      { role: "system", content: SYSTEM_PROMPT },
      {
        role: "user",
        content: `Please provide the translation, IPA transcription, and Russian pronunciation hint for the English word: **${word}**. If it's not an English word, note that in your response.`
      }
    ]
  });
  const response = await httpsRequest({
    url: CHAT_URL,
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      Authorization: `Bearer ${token}`
    },
    body
  });
  const data = JSON.parse(response.body);
  const content = data.choices[0].message.content;
  return parseResponse(content);
}
function formatMarkdown(result) {
  let md = `
\u0427\u0442\u043E \u043E\u0437\u043D\u0430\u0447\u0430\u0435\u0442 ${result.partOfSpeech} ${result.word}?
`;
  md += `?
`;
  md += `\u041E\u0437\u043D\u0430\u0447\u0430\u0435\u0442 "${result.translation}" /${result.transcription}/ (${result.pronunciation})
`;
  md += `\u041F\u0440\u0438\u043C\u0435\u0440\u044B \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F:
`;
  md += `${result.example1_en} \u2014 ${result.example1_ru},
`;
  md += `${result.example2_en} \u2014 ${result.example2_ru},
`;
  md += `${result.example3_en} \u2014 ${result.example3_ru}

`;
  return md;
}
var WordInputModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Translate English Word" });
    const input = contentEl.createEl("input", {
      type: "text",
      placeholder: "Enter an English word..."
    });
    input.style.width = "100%";
    input.style.padding = "8px";
    input.style.marginBottom = "12px";
    const submitBtn = contentEl.createEl("button", {
      text: "Translate",
      cls: "mod-cta"
    });
    const onSubmit = async () => {
      const word = input.value.trim();
      if (!word) {
        new import_obsidian.Notice("Please enter a word.");
        return;
      }
      if (!this.plugin.settings.gigachatCredentials) {
        new import_obsidian.Notice("GigaChat credentials not set. Check plugin settings.");
        return;
      }
      this.close();
      new import_obsidian.Notice(`Translating "${word}"...`);
      try {
        const result = await lookupWord(word, this.plugin.settings.gigachatCredentials);
        const markdown = formatMarkdown(result);
        await this.plugin.appendToFile(markdown);
        new import_obsidian.Notice(`"${result.word}" saved to ${this.plugin.settings.filePath}`);
      } catch (e) {
        console.error("English Words plugin error:", e);
        new import_obsidian.Notice(`Error: ${e instanceof Error ? e.message : String(e)}`);
      }
    };
    submitBtn.addEventListener("click", onSubmit);
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        onSubmit();
      }
    });
    input.focus();
  }
  onClose() {
    this.contentEl.empty();
  }
};
var EnglishWordsPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "english-words-lookup",
      name: "Translate English word",
      callback: () => {
        new WordInputModal(this.app, this).open();
      }
    });
    this.addSettingTab(new EnglishWordsSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async appendToFile(content) {
    const filePath = this.settings.filePath;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian.TFile) {
      const existing = await this.app.vault.read(file);
      await this.app.vault.modify(file, existing + content);
    } else {
      await this.app.vault.create(filePath, `# English Words
${content}`);
    }
  }
};
var EnglishWordsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("GigaChat Credentials").setDesc("Authorization key from developers.sber.ru (base64)").addText(
      (text) => text.setPlaceholder("Enter your credentials").setValue(this.plugin.settings.gigachatCredentials).onChange(async (value) => {
        this.plugin.settings.gigachatCredentials = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Dictionary file path").setDesc("Path to the file in vault where words will be saved").addText(
      (text) => text.setPlaceholder("English Words.md").setValue(this.plugin.settings.filePath).onChange(async (value) => {
        this.plugin.settings.filePath = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
