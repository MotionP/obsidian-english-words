/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => EnglishWordsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  gigachatCredentials: "",
  filePath: "English Words.md"
};
var OAUTH_URL = "https://ngw.devices.sberbank.ru:9443/api/v2/oauth";
var CHAT_URL = "https://gigachat.devices.sberbank.ru/api/v1/chat/completions";
var SYSTEM_PROMPT = "You are a linguistic assistant. Your response must be structured as follows:\n- **word**: the English word or a message indicating it's not an English word.\n- **translation**: the Russian translation or a message indicating it's not an English word.\n- **transcription**: IPA phonetic transcription or a message indicating it's not an English word.\n- **pronunciation**: approximate Russian pronunciation hint or a message indicating it's not an English word.\n- **examples**: 3 common everyday example sentences using the word. Each example must have the sentence in English and its Russian translation. Choose sentences that are frequently used in daily life.\nIf the input is not an English word, respond with 'This is not an English word.' for each field.\n\nReply ONLY with the structured data, no extra text. Use exactly this format:\nword: <word>\ntranslation: <translation>\ntranscription: <transcription>\npronunciation: <pronunciation>\nexample1_en: <sentence>\nexample1_ru: <translation>\nexample2_en: <sentence>\nexample2_ru: <translation>\nexample3_en: <sentence>\nexample3_ru: <translation>";
function generateUUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
async function getAccessToken(credentials) {
  const response = await (0, import_obsidian.requestUrl)({
    url: OAUTH_URL,
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Accept: "application/json",
      Authorization: `Basic ${credentials}`,
      RqUID: generateUUID()
    },
    body: "scope=GIGACHAT_API_PERS"
  });
  const data = response.json;
  return data.access_token;
}
function parseResponse(text) {
  const lines = text.split("\n");
  const result = {};
  for (const line of lines) {
    const colonIndex = line.indexOf(":");
    if (colonIndex === -1)
      continue;
    const key = line.substring(0, colonIndex).trim().toLowerCase();
    const value = line.substring(colonIndex + 1).trim();
    result[key] = value;
  }
  return {
    word: result["word"] || "",
    translation: result["translation"] || "",
    transcription: result["transcription"] || "",
    pronunciation: result["pronunciation"] || "",
    example1_en: result["example1_en"] || "",
    example1_ru: result["example1_ru"] || "",
    example2_en: result["example2_en"] || "",
    example2_ru: result["example2_ru"] || "",
    example3_en: result["example3_en"] || "",
    example3_ru: result["example3_ru"] || ""
  };
}
async function lookupWord(word, credentials) {
  const token = await getAccessToken(credentials);
  const response = await (0, import_obsidian.requestUrl)({
    url: CHAT_URL,
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      Authorization: `Bearer ${token}`
    },
    body: JSON.stringify({
      model: "GigaChat-Pro",
      temperature: 0.1,
      messages: [
        { role: "system", content: SYSTEM_PROMPT },
        {
          role: "user",
          content: `Please provide the translation, IPA transcription, and Russian pronunciation hint for the English word: **${word}**. If it's not an English word, note that in your response.`
        }
      ]
    })
  });
  const data = response.json;
  const content = data.choices[0].message.content;
  return parseResponse(content);
}
function formatMarkdown(result) {
  let md = `
## ${result.word}
`;
  md += `- **\u041F\u0435\u0440\u0435\u0432\u043E\u0434:** ${result.translation}
`;
  md += `- **\u0422\u0440\u0430\u043D\u0441\u043A\u0440\u0438\u043F\u0446\u0438\u044F:** ${result.transcription}
`;
  md += `- **\u041F\u0440\u043E\u0438\u0437\u043D\u043E\u0448\u0435\u043D\u0438\u0435:** ${result.pronunciation}

`;
  md += `**\u041F\u0440\u0438\u043C\u0435\u0440\u044B:**
`;
  md += `1. ${result.example1_en}
   ${result.example1_ru}
`;
  md += `2. ${result.example2_en}
   ${result.example2_ru}
`;
  md += `3. ${result.example3_en}
   ${result.example3_ru}

`;
  md += `---
`;
  return md;
}
var WordInputModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Translate English Word" });
    const input = contentEl.createEl("input", {
      type: "text",
      placeholder: "Enter an English word..."
    });
    input.style.width = "100%";
    input.style.padding = "8px";
    input.style.marginBottom = "12px";
    const submitBtn = contentEl.createEl("button", {
      text: "Translate",
      cls: "mod-cta"
    });
    const onSubmit = async () => {
      const word = input.value.trim();
      if (!word) {
        new import_obsidian.Notice("Please enter a word.");
        return;
      }
      if (!this.plugin.settings.gigachatCredentials) {
        new import_obsidian.Notice("GigaChat credentials not set. Check plugin settings.");
        return;
      }
      this.close();
      new import_obsidian.Notice(`Translating "${word}"...`);
      try {
        const result = await lookupWord(word, this.plugin.settings.gigachatCredentials);
        const markdown = formatMarkdown(result);
        await this.plugin.appendToFile(markdown);
        new import_obsidian.Notice(`"${result.word}" saved to ${this.plugin.settings.filePath}`);
      } catch (e) {
        console.error("English Words plugin error:", e);
        new import_obsidian.Notice(`Error: ${e instanceof Error ? e.message : String(e)}`);
      }
    };
    submitBtn.addEventListener("click", onSubmit);
    input.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        onSubmit();
      }
    });
    input.focus();
  }
  onClose() {
    this.contentEl.empty();
  }
};
var EnglishWordsPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "english-words-lookup",
      name: "Translate English word",
      callback: () => {
        new WordInputModal(this.app, this).open();
      }
    });
    this.addSettingTab(new EnglishWordsSettingTab(this.app, this));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async appendToFile(content) {
    const filePath = this.settings.filePath;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian.TFile) {
      const existing = await this.app.vault.read(file);
      await this.app.vault.modify(file, existing + content);
    } else {
      await this.app.vault.create(filePath, `# English Words
${content}`);
    }
  }
};
var EnglishWordsSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("GigaChat Credentials").setDesc("Authorization key from developers.sber.ru (base64)").addText(
      (text) => text.setPlaceholder("Enter your credentials").setValue(this.plugin.settings.gigachatCredentials).onChange(async (value) => {
        this.plugin.settings.gigachatCredentials = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Dictionary file path").setDesc("Path to the file in vault where words will be saved").addText(
      (text) => text.setPlaceholder("English Words.md").setValue(this.plugin.settings.filePath).onChange(async (value) => {
        this.plugin.settings.filePath = value;
        await this.plugin.saveSettings();
      })
    );
  }
};
